["program]\npub mod clawdb {\n    use super::*;\n\n    /// Initialize the ClawDB program\n    pub fn initialize(\n        ctx: Context<Initialize>,\n    ) -> Result<()> {\n        let config = &mut ctx.accounts.config;\n\n        require!(\n            config.is_authority,\n            ErrorCode::InvalidAuthority\n        );\n\n        emit!(InitializeEvent);\n\n        Ok(())\n    }\n\n    /// Create a new data asset\n    pub fn create_asset(\n        ctx: Context<CreateAsset>,\n        metadata_hash: String,\n        data_cid: String,\n        pricing_type: PricingType,\n        price: u64,\n    ) -> Result<()> {\n        let asset = &mut ctx.accounts.asset;\n        let payer = &ctx.accounts.payer;\n        let system_program = &ctx.accounts.system_program;\n\n        // Calculate rent exemption\n        let space = 8 + 32 + 32 + 32 + 1 + 4 + metadata_hash.len() + data_cid.len() + 1 + 4 + 1;\n        let rent = Rent::get().minimum_balance(space);\n\n        // Transfer rent from payer to asset account\n        let cpi_accounts = system_program.to_account_metas(\n            &ctx.accounts.payer,\n            &asset,\n        );\n\n        invoke(\n            cpi_accounts,\n            system_program.transfer(payer.to_account_info(), asset.to_account_info(), rent),\n        )?;\n\n        // Store asset data\n        asset.asset_metadata_hash = metadata_hash;\n        asset.data_cid = data_cid;\n        asset.pricing_type = pricing_type;\n        asset.price = price;\n        asset.created_at = Clock::get().unix_timestamp();\n        asset.updated_at = Clock::get().unix_timestamp();\n        asset.is_active = true;\n\n        emit!(CreateAssetEvent {\n            asset_mint: asset.key(),\n            creator: payer.key(),\n            pricing_type,\n            price,\n        });\n\n        Ok(())\n    }\n\n    /// Update an existing data asset\n    pub fn update_asset(\n        ctx: Context<UpdateAsset>,\n        new_metadata_hash: String,\n        new_data_cid: Option<String>,\n        new_pricing_type: Option<PricingType>,\n        new_price: Option<u64>,\n    ) -> Result<()> {\n        let asset = &mut ctx.accounts.asset;\n        let authority = &ctx.accounts.authority;\n\n        require!(\n            asset.authority == authority.key(),\n            ErrorCode::InvalidAuthority\n        );\n\n        asset.asset_metadata_hash = new_metadata_hash;\n\n        if let Some(cid) = new_data_cid {\n            asset.data_cid = cid;\n        }\n\n        if let Some(pricing) = new_pricing_type {\n            asset.pricing_type = pricing;\n        }\n\n        if let Some(price) = new_price {\n            asset.price = price;\n        }\n\n        asset.updated_at = Clock::get().unix_timestamp();\n\n        emit!(UpdateAssetEvent {\n            asset_mint: asset.key(),\n        });\n\n        Ok(())\n    }\n\n    /// Purchase access to a data asset\n    pub fn purchase_access(\n        ctx: Context<PurchaseAccess>,\n    ) -> Result<()> {\n        let asset = &ctx.accounts.asset;\n        let purchaser = &ctx.accounts.purchaser;\n        let payment = &ctx.accounts.payment;\n        let treasury = &ctx.accounts.treasury;\n        let system_program = &ctx.accounts.system_program;\n\n        // Check asset is active\n        require!(\n            asset.is_active,\n            ErrorCode::AssetInactive\n        );\n\n        // Check payment amount matches price\n        require!(\n            payment.amount >= asset.price,\n            ErrorCode::InsufficientPayment\n        );\n\n        // Transfer payment from purchaser to creator\n        let cpi_accounts = system_program.to_account_metas(\n            &payment.to_account_info(),\n            &asset.to_account_info(),\n            &treasury.to_account_info(),\n        );\n\n        invoke(\n            cpi_accounts,\n            system_program.transfer(\n                payment.to_account_info(),\n                asset.to_account_info(),\n                asset.price,\n            ),\n        )?;\n\n        emit!(PurchaseEvent {\n            asset_mint: asset.key(),\n            purchaser: purchaser.key(),\n            amount: asset.price,\n        });\n\n        Ok(())\n    }\n\n    /// Rate a data asset (builds reputation)\n    pub fn rate_asset(\n        ctx: Context<RateAsset>,\n        rating: u8, // 1-5 stars\n    ) -> Result<()> {\n        let asset = &mut ctx.accounts.asset;\n        let rater = &ctx.accounts.rater;\n        let system_program = &ctx.accounts.system_program;\n\n        // Transfer rating fee (small) to cover oracle verification\n        let rating_fee = 1000; // 0.000001 SOL\n        let cpi_accounts = system_program.to_account_metas(\n            &rater.to_account_info(),\n            &asset.to_account_info(),\n        );\n\n        invoke(\n            cpi_accounts,\n            system_program.transfer(rater.to_account_info(), asset.to_account_info(), rating_fee),\n        )?;\n\n        // Update rating\n        let total_stars = asset.total_ratings as u64 + rating as u64;\n        let avg_rating = (total_stars as u128 / asset.total_ratings as u128) as u64;\n\n        asset.total_ratings = asset.total_ratings + 1;\n        asset.average_rating = avg_rating;\n        asset.updated_at = Clock::get().unix_timestamp();\n\n        emit!(RateAssetEvent {\n            asset_mint: asset.key(),\n            rating,\n            new_average_rating: asset.average_rating,\n        });\n\n        Ok(())\n    }\n\n    /// Deactivate an asset (creator only)\n    pub fn deactivate_asset(\n        ctx: Context<DeactivateAsset>,\n    ) -> Result<()> {\n        let asset = &mut ctx.accounts.asset;\n        let authority = &ctx.accounts.authority;\n\n        require!(\n            asset.authority == authority.key(),\n            ErrorCode::InvalidAuthority\n        );\n\n        asset.is_active = false;\n        asset.updated_at = Clock::get().unix_timestamp();\n\n        emit!(DeactivateAssetEvent {\n            asset_mint: asset.key(),\n        });\n\n        Ok(())\n    }\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Invalid authority", "InvalidAuthority,\n    #[msg(\"Asset is inactive", "AssetInactive,\n    #[msg(\"Insufficient payment", "InsufficientPayment,\n}\n\n#[event]\npub struct InitializeEvent;\n\n#[event]\npub struct CreateAssetEvent {\n    pub asset_mint: Pubkey,\n    pub creator: Pubkey,\n    pub pricing_type: PricingType,\n    pub price: u64,\n}\n\n#[event]\npub struct UpdateAssetEvent {\n    pub asset_mint: Pubkey,\n}\n\n#[event]\npub struct PurchaseEvent {\n    pub asset_mint: Pubkey,\n    pub purchaser: Pubkey,\n    pub amount: u64,\n}\n\n#[event]\npub struct RateAssetEvent {\n    pub asset_mint: Pubkey,\n    pub rating: u8,\n    pub new_average_rating: u64,\n}\n\n#[event]\npub struct DeactivateAssetEvent {\n    pub asset_mint: Pubkey,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq)]\npub enum PricingType {\n    PerQuery,\n    Subscription,\n}\n\nimpl Default for PricingType {\n    fn default() -> Self {\n        Self::PerQuery\n    }\n}\n\n#[account]\npub struct Initialize<'info> {\n    #[account(\n        init,\n        payer = authority,\n        seeds::program::authority::AUTH_SEED,\n        bump,\n    )]\n    pub authority: Signer<'info>,\n    #[account(mut)]\n    pub config: SystemAccount<'info>,\n}\n\n#[account]\npub struct CreateAsset<'info> {\n    #[account(\n        init,\n        payer = payer,\n        space = 8 + 32 + 32 + 32 + 1 + 200 + 200 + 1 + 4 + 1,\n    )]\n    pub asset: Account<'info, DataAsset>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct DataAsset {\n    pub authority: Pubkey,\n    pub creator: Pubkey,\n    pub asset_metadata_hash: String,\n    pub data_cid: String,\n    pub pricing_type: PricingType,\n    pub price: u64,\n    pub created_at: i64,\n    pub updated_at: i64,\n    pub total_ratings: u32,\n    pub average_rating: u64,\n    pub is_active: bool,\n    pub padding: [u8; 200],\n}\n\n#[account]\npub struct UpdateAsset<'info> {\n    #[account(mut)]\n    pub asset: Account<'info, DataAsset>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct PurchaseAccess<'info> {\n    #[account(mut)]\n    pub asset: Account<'info, DataAsset>,\n    #[account(mut)]\n    pub purchaser: Signer<'info>,\n    #[account(mut)]\n    pub payment: Account<'info, Payment>,\n    #[account(mut)]\n    pub treasury: Account<'info, Treasury>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy)]\npub struct Payment {\n    pub amount: u64,\n    pub payer: Pubkey,\n}\n\n#[account]\npub struct Treasury<'info> {\n    #[account(\n        init,\n        seeds::program::authority::AUTH_SEED,\n        bump,\n    )]\n    pub treasury: SystemAccount<'info>,\n}\n\n#[account]\npub struct RateAsset<'info> {\n    #[account(mut)]\n    pub asset: Account<'info, DataAsset>,\n    pub rater: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct DeactivateAsset<'info> {\n    #[account(mut)]\n    pub asset: Account<'info, DataAsset>,\n    pub authority: Signer<'info>,\n}"]